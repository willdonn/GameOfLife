package Board;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;

public class BoardModel {

	
	private List<List<CellPanel>> board;
	private Map<Position,Boolean> nextState;
	private Map<Position,CellModel> releventCells;
	
	private int width;
	private int height;
	private int speed = 5;
	private int time = 0;
	
	public BoardModel(int width, int height) {
		this.width = width;
		this.height = height;
		initBoard();
	}
	
	private void initBoard() {
		board = new ArrayList<List<CellPanel>>();
		nextState = new Hashtable<Position,Boolean>();
		releventCells = new Hashtable<Position,CellModel>();
		for (int y = 0; y < height; y++) {
			ArrayList<CellPanel> boardRow = new ArrayList<CellPanel>();
			ArrayList<Boolean> stateRow = new ArrayList<Boolean>();
			for (int x = 0; x < width; x++) {
				boardRow.add(new CellPanel(new Position(x, y)));
				stateRow.add(false);
			}
			board.add(boardRow);
		}
	}
	
	public int getHeight() {
		// TODO Auto-generated method stub
		return height;
	}

	public int getWidth() {
		// TODO Auto-generated method stub
		return width;
	}
	
	public List<List<CellPanel>> getBoard(){
		return board;
	}

	public void reset() {
		for (int x = 0; x < width; x++) {
			for (int y = 0; y < height; y++) {
				board.get(y).get(x).getModel().setAlive(false);
			}
		}
		time = 0;
	}
	
	private void getNextState(CellModel cell) {
	
		if (cell.isAlive() && (cell.numNeighbors() < 2 || cell.numNeighbors() > 3)) {
			nextState.put(cell.getPosition(), false);
		} else if (!cell.isAlive() && (cell.numNeighbors() == 3)) {
			nextState.put(cell.getPosition(), true);
		} else
			nextState.put(cell.getPosition(),cell.isAlive());
		
	}

	public void updateBoard() {
		
		for (CellModel releventCell : releventCells.values()) {
			getNextState(releventCell);
		}
		
		for (CellModel releventCell : releventCells.values()) {
			if (nextState.get(releventCell.getPosition()) != releventCell.isAlive()) {
				releventCell.setAlive(nextState.get(releventCell.getPosition()));
				updateNeighbors(releventCell);
			}
		}
		
		time++;
		
	}
	
	public Map<Position, CellModel> getReleventCells(){
		return releventCells;
	}

	public int getSpeed() {
		return speed;
	}

	public void setSpeed(int speed) {
		this.speed = speed;
	}

	public int getTime() {
		// TODO Auto-generated method stub
		return time;
	}

	public void updateNeighbors(CellModel cell) {
		
		Position[] neighbors = new Position[8];
		int idx = 0;
		for (int deltaX = -1; deltaX < 2; deltaX++) {
			for (int deltaY = -1; deltaY < 2; deltaY++) {
				if (deltaX != 0 || deltaY != 0){
					neighbors[idx++] = new Position(cell.getPosition().x + deltaX, cell.getPosition().y + deltaY);
				}
			}
		}
		
		for (int i = 0; i < neighbors.length; i++) {
			updateReleventCell(neighbors[i], cell);
		}
		
	}
	
	private boolean onBoard(Position position) {

		return position.x < width && position.x >= 0 && position.y < height && position.y >= 0;
		
	}
	
	//Update relevent cells so that it does not get modified during iteration
	private void updateReleventCell(Position position, CellModel cell) {
		if (cell.isAlive()) {
			if (releventCells.containsKey(position)) releventCells.get(position).addNeighbor(cell);
			else {
				CellModel releventCell = (onBoard(position)) ? board.get(position.y).get(position.x).getModel() : new CellModel(position);
				releventCell.addNeighbor(cell);
				releventCells.put(releventCell.getPosition(), releventCell);
			}
		} else if (releventCells.containsKey(position)) {
			CellModel releventCell = releventCells.get(position);
			if (!releventCell.isAlive()) {
				releventCell.removeNeighbor(cell);
				if (!releventCell.hasNeighbor()) releventCells.remove(releventCell.getPosition());
				if (!cell.hasNeighbor()) releventCells.remove(cell.getPosition());
			}
					
		}
		
	}

}
